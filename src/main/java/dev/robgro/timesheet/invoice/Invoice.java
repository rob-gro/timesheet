package dev.robgro.timesheet.invoice;

import dev.robgro.timesheet.client.Client;
import dev.robgro.timesheet.exception.ValidationException;
import dev.robgro.timesheet.seller.Seller;
import dev.robgro.timesheet.timesheet.Timesheet;
import dev.robgro.timesheet.tracking.EmailTracking;
import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;

@Entity
@Getter
@Setter
@Table(name = "invoices")
public class Invoice {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "invoice_number", unique = true)
    private String invoiceNumber;

    @Column(name = "issue_date")
    private LocalDate issueDate;

    @Column(name = "total_amount")
    private BigDecimal totalAmount;

    @ManyToOne(fetch = FetchType.LAZY, optional = false)
    @JoinColumn(name = "client_id", foreignKey = @ForeignKey(ConstraintMode.NO_CONSTRAINT))
    private Client client;

    @ManyToOne(fetch = FetchType.LAZY, optional = false)
    @JoinColumn(name = "seller_id")
    private Seller seller;

    @OneToMany(mappedBy = "invoice", cascade = CascadeType.ALL, orphanRemoval = true)
    private List<InvoiceItem> itemsList = new ArrayList<>();

    @Column(name = "issued_date")
    private LocalDateTime issuedDate;

    @Column(name = "pdf_path")
    private String pdfPath;

    @Column(name = "pdf_generated_at")
    private LocalDateTime pdfGeneratedAt;

    @Column(name = "email_sent_at")
    private LocalDateTime emailSentAt;

    @Column(name = "email_tracking_token", length = 255)
    private String emailTrackingToken;

    @Column(name = "email_opened_at")
    private LocalDateTime emailOpenedAt;

    @Column(name = "email_open_count")
    private Integer emailOpenCount = 0;

    @Column(name = "last_email_opened_at")
    private LocalDateTime lastEmailOpenedAt;

    @OneToMany(mappedBy = "invoice")
    private List<Timesheet> timesheets = new ArrayList<>();

    // ===== Invoice Numbering Components (Configurable System) =====

    /**
     * Sequence number within the period (e.g., 1, 2, 3...)
     * Resets based on reset_period: MONTHLY (every month), YEARLY (every year), or NEVER (continuous)
     * Made NOT NULL in V23 after V21 backfill completes
     */
    @Column(name = "sequence_number")
    private Integer sequenceNumber;

    /**
     * Year component for sorting and period calculation (e.g., 2026)
     * Made NOT NULL in V23 after V21 backfill completes
     */
    @Column(name = "period_year")
    private Integer periodYear;

    /**
     * Month component for MONTHLY reset periods (1-12)
     * CRITICAL: Must be 0 (not NULL) for YEARLY/NEVER to avoid UNIQUE constraint issues
     * Made NOT NULL in V23
     */
    @Column(name = "period_month")
    private Integer periodMonth = 0;

    /**
     * Department for multi-department numbering (v1 feature)
     * Optional - used when seller has multiple departments with separate sequences
     */
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "department_id")
    private Department department;

    /**
     * ID of the numbering scheme that generated this invoice number.
     * Audit trail: allows tracing back "which template/reset_period was active".
     * NULL for invoices created before V29 migration.
     */
    @Column(name = "scheme_id")
    private Long schemeId;

    /**
     * Human-readable formatted invoice number (e.g., "001-01-2026", "INV-123-2024")
     * Generated by applying template to components
     */
    @Column(name = "invoice_number_display", length = 64)
    private String invoiceNumberDisplay;

    // ===== Business Methods =====

    /**
     * Updates email tracking status from EmailTracking entity
     * Called when email is opened
     */
    public void updateEmailOpenStatus(EmailTracking tracking) {
        this.emailOpenedAt = tracking.getOpenedAt();
        this.emailOpenCount = tracking.getOpenCount();
        this.lastEmailOpenedAt = tracking.getLastOpenedAt();
    }

    /**
     * Sets invoice number components from generated number.
     * Validates all components before setting to ensure data integrity.
     * Also updates deprecated invoiceNumber field for backward compatibility.
     *
     * @param sequenceNumber Sequence within period (must be >= 1)
     * @param periodYear Year component (required)
     * @param periodMonth Month: 1-12 for MONTHLY, 0 for YEARLY/NEVER
     * @param displayNumber Formatted invoice number (required)
     * @throws ValidationException if any validation fails
     */
    public void setInvoiceNumberComponents(
        Integer sequenceNumber,
        Integer periodYear,
        Integer periodMonth,
        String displayNumber,
        Long schemeId
    ) {
        validateSequenceNumber(sequenceNumber);
        validatePeriodYear(periodYear);
        validatePeriodMonth(periodMonth);

        if (displayNumber == null || displayNumber.isBlank()) {
            throw new ValidationException("Display number is required");
        }

        this.sequenceNumber = sequenceNumber;
        this.periodYear = periodYear;
        this.periodMonth = periodMonth;
        this.invoiceNumberDisplay = displayNumber;
        this.schemeId = schemeId;

        // Backward compatibility: keep old field populated
        this.invoiceNumber = displayNumber;
    }

    private void validateSequenceNumber(Integer seq) {
        if (seq == null || seq < 1) {
            throw new ValidationException(
                "Sequence number must be >= 1, got: " + seq
            );
        }
    }

    private void validatePeriodYear(Integer year) {
        if (year == null) {
            throw new ValidationException("Period year is required");
        }
        if (year < 1900 || year > 2200) {
            throw new ValidationException(
                "Period year must be between 1900-2200, got: " + year
            );
        }
    }

    private void validatePeriodMonth(Integer month) {
        if (month == null || month < 0 || month > 12) {
            throw new ValidationException(
                "Period month must be 0-12 (0=yearly/never, 1-12=monthly), got: " + month
            );
        }
    }

    /**
     * Checks if email was sent but not opened within given days
     */
    public boolean isEmailUnopened(int daysThreshold) {
        if (emailSentAt == null) return false;
        if (emailOpenedAt != null) return false;

        return emailSentAt.plusDays(daysThreshold).isBefore(LocalDateTime.now());
    }

    /**
     * Gets email status as human-readable string
     */
    public String getEmailStatus() {
        if (emailSentAt == null) return "NOT_SENT";
        if (emailOpenedAt == null) {
            if (isEmailUnopened(7)) return "UNOPENED_WARNING";
            return "SENT_UNOPENED";
        }
        return "OPENED";
    }
}
